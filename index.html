<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Orbital Arena | Vanguard Evolved</title>
    <style>
        :root { --bg: #050507; --panel: #111114; --accent: #d4af37; --text: #e0e0e0; --danger: #ff4d4d; }
        body { background: var(--bg); color: var(--text); margin: 0; display: flex; font-family: 'Segoe UI', sans-serif; height: 100vh; overflow: hidden; }
        
        #sidebar { width: 320px; background: var(--panel); display: flex; flex-direction: column; padding: 20px; border-right: 1px solid #2d2d35; box-sizing: border-box; }
        .header h1 { font-size: 0.9rem; letter-spacing: 5px; color: var(--accent); text-align: center; margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        
        #game-info { background: #1a1a1f; padding: 15px; border-radius: 4px; text-align: center; border-left: 3px solid var(--accent); margin-bottom: 15px; }
        #timer-box { font-size: 2.2rem; font-weight: 800; color: var(--accent); }
        .turn-label { font-size: 0.7rem; color: #777; text-transform: uppercase; }

        #rules-primer { background: rgba(212, 175, 55, 0.05); padding: 12px; border-radius: 4px; font-size: 0.75rem; color: #aaa; margin-bottom: 15px; border: 1px solid #2d2d35; }
        #rules-primer h2 { font-size: 0.65rem; color: var(--accent); letter-spacing: 2px; text-transform: uppercase; margin: 0 0 8px 0; }

        #gallery { flex-grow: 1; border-top: 1px solid #2d2d35; padding-top: 15px; overflow-y: auto; }
        .captured-row { display: flex; flex-wrap: wrap; gap: 4px; min-height: 30px; margin-bottom: 15px; }
        .captured-piece { font-size: 1.4rem; }

        canvas { flex-grow: 1; cursor: crosshair; background: #000; }
        .btn { background: var(--accent); color: #000; border: none; padding: 12px; border-radius: 2px; font-weight: 800; cursor: pointer; width: 100%; text-transform: uppercase; }

        #overlay, #victory-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .start-box { text-align:center; background:#111114; padding:60px; border: 1px solid var(--accent); }
        
        #check-alert { position: absolute; top: 10%; left: 50%; translate: -50% 0; color: var(--danger); font-weight: 900; font-size: 3rem; letter-spacing: 15px; opacity: 0; pointer-events: none; transition: 0.3s; }
        .show-check { opacity: 1 !important; }
    </style>
</head>
<body>
    <div id="check-alert">CHECK</div>
    
    <div id="overlay">
        <div class="start-box">
            <h1 style="color:var(--accent); letter-spacing:8px; margin-bottom:10px;">VANGUARD : ORBITAL</h1>
            <p style="color:#666; font-size:0.8rem; margin-bottom:30px;">SELECT YOUR DEPLOYMENT SIDE</p>
            <div style="display:flex; gap:15px;">
                <button class="btn" onclick="startGame('w')">Command White</button>
                <button class="btn" style="background:#eee;" onclick="startGame('b')">Command Black</button>
            </div>
        </div>
    </div>

    <div id="victory-overlay" style="display:none;">
        <div class="start-box">
            <h1 id="winner-text" style="color:var(--accent); letter-spacing:5px;">TERMINATED</h1>
            <p id="sub-winner-text" style="color:#888; margin-bottom:20px;">FORFEIT</p>
            <button class="btn" onclick="showChoiceMenu()">New Match / Swap Sides</button>
        </div>
    </div>

    <div id="sidebar">
        <div class="header"><h1>TACTICAL INTERFACE</h1></div>
        <div id="game-info">
            <div class="turn-label" id="turn-text">WAITING...</div>
            <div id="timer-box">60s</div>
        </div>
        <div id="rules-primer">
            <h2>Vanguard Protocol</h2>
            <ul>
                <li><b>Toroidal:</b> Infinite wrap on all edges.</li>
                <li><b>Inertia:</b> Majors must move <b>Forward</b> on Turn 1.</li>
                <li><b>Blitz:</b> AI processes in &lt; 2 seconds.</li>
            </ul>
        </div>
        <div id="gallery">
            <div id="captured-by-ai" class="captured-row"></div>
            <div id="captured-by-player" class="captured-row"></div>
        </div>
        <button class="btn" onclick="showChoiceMenu()" style="background:transparent; color:#555; border:1px solid #333;">Abort</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const ROWS = 12, COLS = 16, CELL = 60;
    let board = [], hasMoved = [], turn = 'w', myColor = 'w', timerInterval, timeLeft = 60;
    let selected = null, validMoves = [], lastMove = null, gameActive = false;

    const VALS = { 'P': 120, 'N': 480, 'B': 420, 'R': 680, 'Q': 1250, 'K': 50000 };
    const PIECES = {'wK':'♔','wQ':'♕','wR':'♖','wB':'♗','wN':'♘','wP':'♙','bK':'♚','bQ':'♛','bR':'♜','bB':'♝','bN':'♞','bP':'♟'};

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function showChoiceMenu() {
        gameActive = false;
        clearInterval(timerInterval);
        document.getElementById('victory-overlay').style.display = 'none';
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('captured-by-ai').innerHTML = '';
        document.getElementById('captured-by-player').innerHTML = '';
        lastMove = null;
    }

    function startGame(side) {
        myColor = side;
        turn = 'w'; // White always starts
        gameActive = true;
        document.getElementById('overlay').style.display = 'none';
        initBoard();
        resetTimer();
        if(turn !== myColor) aiMove();
        requestAnimationFrame(render);
    }

    function initBoard() {
        board = Array(ROWS).fill().map(() => Array(COLS).fill(""));
        hasMoved = Array(ROWS).fill().map(() => Array(COLS).fill(false));
        const layout = ["R","N","B","Q","K","B","N","R"];
        layout.forEach((p, i) => {
            board[2][4+i] = "b"+p; board[3][4+i] = "bP";
            board[9][4+i] = "w"+p; board[8][4+i] = "wP";
        });
    }

    function getMoves(r, c, targetBoard = board, history = hasMoved) {
        const piece = targetBoard[r][c]; if(!piece) return [];
        const col = piece[0], type = piece[1], moves = [], fwd = col==='w'?-1:1;
        const isFirst = !history[r][c];

        if(type==='P') {
            let nr = (r+fwd+ROWS)%ROWS; 
            if(!targetBoard[nr][c]) moves.push({r:nr, c:c});
            [-1, 1].forEach(dc => {
                let nc = (c+dc+COLS)%COLS;
                if(targetBoard[nr][nc] && targetBoard[nr][nc][0] !== col) moves.push({r:nr, c:nc});
            });
        } else {
            let dirs = (type==='N')?[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]:
                       (type==='R')?[[0,1],[0,-1],[1,0],[-1,0]]:
                       (type==='B')?[[1,1],[1,-1],[-1,1],[-1,-1]]:
                                    [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            if (isFirst && type !== 'K') dirs = dirs.filter(d => (col === 'w' ? d[0] < 0 : d[0] > 0));
            const lim = (type==='K' || type==='N') ? 2 : 16;
            dirs.forEach(([dr, dc]) => {
                for(let i=1; i<lim; i++) {
                    let nr = (r + dr*i + ROWS) % ROWS, nc = (c + dc*i + COLS) % COLS;
                    if(targetBoard[nr][nc] && targetBoard[nr][nc][0] === col) break;
                    moves.push({r:nr, c:nc}); if(targetBoard[nr][nc]) break;
                }
            });
        }
        return moves;
    }

    function aiMove() {
        if (!gameActive) return;
        const aiColor = (myColor === 'w' ? 'b' : 'w');
        const opponent = myColor;
        setTimeout(() => {
            let bestMove = null, bestScore = -Infinity, moves = [];
            let kPos = null;
            for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) if(board[r][c] === opponent + 'K') kPos = {r,c};

            for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) 
                if(board[r][c] && board[r][c][0] === aiColor) 
                    getMoves(r, c).forEach(m => moves.push({fr:r, fc:c, tr:m.r, tc:m.c, p:board[r][c]}));

            moves.forEach(move => {
                let score = Math.random() * 10;
                const target = board[move.tr][move.tc];
                if(target) score += VALS[target[1]] * 15;
                if(!hasMoved[move.fr][move.fc] && move.p[1] !== 'P') score += 250;
                if(kPos) {
                    const rD = Math.min(Math.abs(move.tr - kPos.r), ROWS - Math.abs(move.tr - kPos.r));
                    const cD = Math.min(Math.abs(move.tc - kPos.c), COLS - Math.abs(move.tc - kPos.c));
                    score += (20 - (rD + cD)) * 8;
                }
                const backupS = board[move.fr][move.fc], backupT = board[move.tr][move.tc];
                board[move.tr][move.tc] = backupS; board[move.fr][move.fc] = "";
                let danger = 0;
                for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++)
                    if(board[r][c] && board[r][c][0] === opponent)
                        getMoves(r, c).forEach(oppM => { if(board[oppM.r][oppM.c] && board[oppM.r][oppM.c][0] === aiColor) danger = Math.max(danger, VALS[board[oppM.r][oppM.c][1]]); });
                score -= (danger * 1.8);
                board[move.fr][move.fc] = backupS; board[move.tr][move.tc] = backupT;
                if(score > bestScore) { bestScore = score; bestMove = move; }
            });

            if(bestMove && gameActive) executeMove(bestMove.fr, bestMove.fc, bestMove.tr, bestMove.tc);
        }, 400);
    }

    function executeMove(fr, fc, tr, tc) {
        if(!gameActive) return;
        let piece = board[fr][fc];
        const victim = board[tr][tc];
        if(victim) {
            updateGallery(victim);
            if(victim[1] === 'K') return endGame(piece[0] === myColor ? "PLAYER" : "AI", "REGICIDE");
        }
        if(piece[1] === 'P' && (tr === 0 || tr === ROWS - 1)) piece = piece[0] + 'Q';
        board[tr][tc] = piece; board[fr][fc] = "";
        hasMoved[tr][tc] = true;
        lastMove = {fr, fc, tr, tc};
        turn = (turn === 'w' ? 'b' : 'w');
        resetTimer();
        if(gameActive && turn !== myColor) aiMove();
    }

    function updateGallery(piece) {
        const id = piece[0] === myColor ? 'captured-by-ai' : 'captured-by-player';
        const span = document.createElement('span');
        span.className = 'captured-piece'; span.innerText = PIECES[piece];
        span.style.color = piece[0] === 'w' ? '#fff' : '#d4af37';
        document.getElementById(id).appendChild(span);
    }

    function resetTimer() {
        clearInterval(timerInterval);
        timeLeft = (turn === myColor) ? 60 : 2;
        document.getElementById('timer-box').innerText = timeLeft + "s";
        document.getElementById('turn-text').innerText = (turn === myColor) ? "COMMANDER TURN" : "AI PROCESSING";
        timerInterval = setInterval(() => {
            timeLeft--;
            document.getElementById('timer-box').innerText = Math.max(0, timeLeft) + "s";
            if(timeLeft <= 0) endGame((turn === myColor) ? "AI" : "PLAYER", "TIME ELAPSED");
        }, 1000);
    }

    function endGame(winner, reason) {
        gameActive = false; clearInterval(timerInterval);
        document.getElementById('victory-overlay').style.display = 'flex';
        document.getElementById('winner-text').innerText = winner === "PLAYER" ? "ARENA CONQUERED" : "VANGUARD VICTORIOUS";
        document.getElementById('sub-winner-text').innerText = reason;
    }

    function render() {
        if(!gameActive && board.length === 0) return;
        canvas.width = window.innerWidth - 320; canvas.height = window.innerHeight;
        const ox = (canvas.width - COLS*CELL)/2, oy = (canvas.height - ROWS*CELL)/2;
        ctx.clearRect(0,0,canvas.width,canvas.height);
        for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
            let dr = myColor==='b' ? ROWS-1-r : r, dc = myColor==='b' ? COLS-1-c : c;
            const x = dc*CELL+ox, y = dr*CELL+oy;
            ctx.fillStyle = (r+c)%2===0 ? "#0a0a0c" : "#121216"; ctx.fillRect(x,y,CELL,CELL);
            if(lastMove && ((lastMove.fr===r && lastMove.fc===c) || (lastMove.tr===r && lastMove.tc===c))) { ctx.fillStyle = "rgba(212,175,55,0.1)"; ctx.fillRect(x,y,CELL,CELL); }
            if(selected && selected.r === r && selected.c === c) { ctx.fillStyle = "rgba(212,175,55,0.2)"; ctx.fillRect(x,y,CELL,CELL); }
            validMoves.forEach(m => { if(m.r===r && m.c===c) { ctx.fillStyle = "rgba(255,255,255,0.2)"; ctx.beginPath(); ctx.arc(x+CELL/2, y+CELL/2, 4, 0, 7); ctx.fill(); }});
            if(board[r][c]) {
                ctx.fillStyle = board[r][c][0] === 'w' ? "#fff" : "#d4af37";
                ctx.font = "32px serif"; ctx.textAlign = "center"; ctx.fillText(PIECES[board[r][c]], x+CELL/2, y+CELL/2+11);
            }
        }
        requestAnimationFrame(render);
    }

    canvas.addEventListener('mousedown', e => {
        if(!gameActive || turn !== myColor) return;
        const rect = canvas.getBoundingClientRect();
        let c = Math.floor((e.clientX - rect.left - (canvas.width - COLS*CELL)/2) / CELL);
        let r = Math.floor((e.clientY - rect.top - (canvas.height - ROWS*CELL)/2) / CELL);
        if(myColor === 'b') { r = ROWS-1-r; c = COLS-1-c; }
        const move = validMoves.find(m => m.r === r && m.c === c);
        if(move) { executeMove(selected.r, selected.c, r, c); selected = null; validMoves = []; }
        else if(board[r][c] && board[r][c][0] === myColor) { selected = {r, c}; validMoves = getMoves(r, c); }
    });
</script>
</body>
</html>

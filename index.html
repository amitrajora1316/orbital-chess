<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>VANGUARD: ORBITAL CHESS </title>
    <style>
        :root { --bg: #020204; --panel: #0a0a0f; --accent: #d4af37; --text: #d2d2dc; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; }
        
        #sidebar { width: 320px; background: var(--panel); padding: 25px; border-right: 1px solid #2a2a35; display: flex; flex-direction: column; }
        .timer-box { background: #11111d; padding: 15px; border-radius: 4px; border: 1px solid #d4af3733; margin-bottom: 15px; }
        .fuel-bar { height: 4px; background: #1a1a25; margin-top: 8px; }
        .fuel-fill { height: 100%; transition: width 0.1s linear; }

        /* Overlays */
        #overlay, #victory-overlay { 
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: rgba(2,2,4,0.98); display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 1000; text-align: center; 
        }
        #victory-overlay { display: none; background: rgba(2,2,4,0.9); }
        
        .btn { background: none; border: 1px solid var(--accent); color: var(--accent); padding: 12px 30px; margin: 10px; cursor: pointer; letter-spacing: 3px; }
        .btn:hover { background: var(--accent); color: #000; }
        #move-log { flex-grow: 1; background: #050508; padding: 12px; font-family: monospace; font-size: 0.7rem; overflow-y: auto; color: #666; }
    </style>
</head>
<body>

<div id="overlay">
    <h1 style="letter-spacing: 12px; color: var(--accent);">VANGUARD </h1>
    <div id="lang-btns">
        <button class="btn" onclick="setLang('en')">ENGLISH</button>
        <button class="btn" onclick="setLang('de')">DEUTSCH</button>
    </div>
    <div id="side-selection" style="display:none;">
        <button class="btn" id="btn-w" onclick="startGame('w')">WHITE</button>
        <button class="btn" id="btn-b" onclick="startGame('b')">BLACK</button>
    </div>
</div>

<div id="victory-overlay">
    <h1 id="victory-title" style="letter-spacing: 8px; color: var(--accent);">MISSION ACCOMPLISHED</h1>
    <p id="victory-msg" style="margin-bottom: 30px;">Enemy King Neutralized</p>
    <button class="btn" onclick="location.reload()">RESTART GAME</button>
</div>

<div id="sidebar">
    <div id="turn-prompt" style="color:var(--accent); text-align:center; margin-bottom:10px; font-weight:bold; display:none;">YOUR TURN</div>
    <div class="timer-box">
        <div style="display:flex; justify-content: space-between; font-size: 0.65rem;"><span>WHITE FUEL</span> <span id="tw-val">60.0s</span></div>
        <div class="fuel-bar"><div id="bw-fill" class="fuel-fill" style="background: var(--accent); width: 100%;"></div></div>
        <div style="display:flex; justify-content: space-between; font-size: 0.65rem; margin-top: 12px;"><span>BLACK FUEL</span> <span id="tb-val">60.0s</span></div>
        <div class="fuel-bar"><div id="bb-fill" class="fuel-fill" style="background: #7a7a9a; width: 100%;"></div></div>
    </div>
    <div id="move-log"></div>
</div>

<div id="canvas-container"><canvas id="gameCanvas"></canvas></div>

<script>
const ROWS = 8, COLS = 16, CELL = 80;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let board, turn = 'w', playerColor = 'w', selected = null, gameActive = false;
let fuel = { w: 60, b: 60 };
let cam = { x: 50, y: 50 }, lastTick = 0;

const PIECES = { wK:'♔', wQ:'♕', wR:'♖', wB:'♗', wN:'♘', wP:'♙', bK:'♚', bQ:'♛', bR:'♜', bB:'♝', bN:'♞', bP:'♟' };

function setLang(l) {
    document.getElementById('lang-btns').style.display = 'none';
    document.getElementById('side-selection').style.display = 'block';
}

function startGame(side) {
    playerColor = side;
    document.getElementById('overlay').style.display = 'none';
    gameActive = true;
    initBoard();
    lastTick = Date.now();
    updateHUD();
    if (playerColor === 'b') setTimeout(aiMove, 800);
    requestAnimationFrame(updateTimer);
}

function initBoard() {
    board = Array(ROWS).fill(null).map(() => Array(COLS).fill(''));
    const layout = ['R','N','B','Q','K','B','N','R'];
    for (let i = 0; i < 8; i++) {
        let col = i + 4;
        board[0][col] = 'bP'; board[1][col] = 'b' + layout[i]; board[2][col] = 'bP';
        board[7][col] = 'wP'; board[6][col] = 'w' + layout[i]; board[5][col] = 'wP';
    }
}

function endGame(winner, reason) {
    gameActive = false;
    document.getElementById('victory-overlay').style.display = 'flex';
    document.getElementById('victory-title').innerText = (winner === playerColor) ? "ARENA SECURED" : "TIME OUT";
    document.getElementById('victory-msg').innerText = reason;
}

function executeMove(from, to) {
    if (!gameActive) return;
    const p = board[from.r][from.c];
    const target = board[to.r][to.c];

    // Check for King Capture IMMEDIATELY
    if (target && target[1] === 'K') {
        board[to.r][to.c] = p;
        board[from.r][from.c] = '';
        endGame(turn, "Enemy King Neutralized");
        return;
    }

    fuel[turn] = Math.min(60, fuel[turn] + 10);
    board[to.r][to.c] = p;
    board[from.r][from.c] = '';
    
    const log = document.getElementById('move-log');
    log.innerHTML = `<div>> ${p[1]} ${from.r}:${from.c} -> ${to.r}:${to.c}</div>` + log.innerHTML;

    turn = turn === 'w' ? 'b' : 'w';
    updateHUD();
    if (gameActive && turn !== playerColor) setTimeout(aiMove, 600);
}

function updateTimer() {
    if (!gameActive) return;
    let now = Date.now(); 
    let delta = (now - lastTick) / 1000; 
    lastTick = now;

    fuel[turn] -= delta;
    if (fuel[turn] <= 0) {
        fuel[turn] = 0;
        const winner = (turn === 'w') ? 'b' : 'w';
        endGame(winner, "Temporal Lockout: Fuel Depleted");
    }

    document.getElementById('tw-val').innerText = fuel.w.toFixed(1) + 's';
    document.getElementById('tb-val').innerText = fuel.b.toFixed(1) + 's';
    document.getElementById('bw-fill').style.width = (fuel.w / 60 * 100) + '%';
    document.getElementById('bb-fill').style.width = (fuel.b / 60 * 100) + '%';
    requestAnimationFrame(updateTimer);
}

function updateHUD() {
    document.getElementById('turn-prompt').style.display = (turn === playerColor) ? 'block' : 'none';
}

// AI and Rendering remains consistent with your previous high-performance setup...
// [Abbreviated for clarity, using the getDisplayCoords and draw logic from previous turn]

function getDisplayCoords(r, c) {
    if (playerColor === 'b') return { dr: (ROWS - 1) - r, dc: (COLS - 1) - c };
    return { dr: r, dc: c };
}

function getActualCoords(dr, dc) {
    if (playerColor === 'b') return { r: (ROWS - 1) - dr, c: (COLS - 1) - dc };
    return { r: dr, c: dc };
}

function draw() {
    canvas.width = window.innerWidth - 320; canvas.height = window.innerHeight;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0, canvas.width, canvas.height);
    if (!board) { requestAnimationFrame(draw); return; }

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const view = getDisplayCoords(r, c);
            const x = view.dc * CELL + cam.x, y = view.dr * CELL + cam.y;
            ctx.fillStyle = (r + c) % 2 === 0 ? '#b57a44' : '#1a1a1a';
            ctx.fillRect(x, y, CELL, CELL);
            if (board[r][c]) {
                ctx.fillStyle = board[r][c][0] === 'w' ? '#fff' : '#b19cd9';
                ctx.font = '36px serif'; ctx.textAlign = 'center';
                ctx.fillText(PIECES[board[r][c]], x + CELL/2, y + CELL/2 + 13);
            }
        }
    }
    requestAnimationFrame(draw);
}

// ...[Include getMoves and aiMove logic here]...
function getMoves(r, c) {
    const p = board[r][c]; if (!p) return [];
    const type = p[1], col = p[0], moves = [];
    if (type === 'P') {
        const fwd = col === 'w' ? -1 : 1;
        const nr = (r + fwd + ROWS) % ROWS;
        if (!board[nr][c]) moves.push({r: nr, c: c});
        [-1, 1].forEach(dc => {
            const nc = (c + dc + COLS) % COLS;
            if (board[nr][nc] && board[nr][nc][0] !== col) moves.push({r: nr, c: nc});
        });
    } else {
        const dirs = {'R':[[0,1],[0,-1],[1,0],[-1,0]], 'B':[[1,1],[1,-1],[-1,1],[-1,-1]], 'Q':[[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]], 'K':[[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]], 'N':[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]}[type];
        const lim = (type === 'K' || type === 'N') ? 2 : 16;
        dirs.forEach(([dr, dc]) => {
            for (let i = 1; i < lim; i++) {
                const nr = (r + dr * i + ROWS) % ROWS, nc = (c + dc * i + COLS) % COLS;
                if (board[nr][nc] && board[nr][nc][0] === col) break;
                moves.push({r: nr, c: nc});
                if (board[nr][nc]) break;
            }
        });
    }
    return moves;
}

<script>
// ... (Keep existing setup, variables, and getMoves logic) ...

/**
 * REPLACED: New Heuristic AI Decision Controller
 */
function aiMove() {
    if (!gameActive) return;
    const aiCol = playerColor === 'w' ? 'b' : 'w';
    const oppCol = playerColor;
    let allMoves = [];

    // 1. Scan the board for all AI pieces
    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            if(board[r][c] && board[r][c][0] === aiCol) {
                // 2. Find all legal moves for this piece
                const potentialMoves = getMoves(r, c);
                potentialMoves.forEach(m => {
                    // 3. Score the move based on intelligence rules
                    let score = evaluateMove(r, c, m.r, m.c, aiCol, oppCol);
                    allMoves.push({from: {r, c}, to: m, score: score});
                });
            }
        }
    }

    // 4. Sort by highest score (Descending)
    allMoves.sort((a, b) => b.score - a.score);

    // 5. Execute the best move found
    if(allMoves.length > 0) {
        // If multiple moves have the same top score, pick between them randomly
        const bestScore = allMoves[0].score;
        const topMoves = allMoves.filter(m => m.score === bestScore);
        const choice = topMoves[Math.floor(Math.random() * topMoves.length)];
        
        executeMove(choice.from, choice.to);
    }
}

/**
 * Logic Brain: Assigns a numeric value to a move
 */
function evaluateMove(fr, fc, tr, tc, aiCol, oppCol) {
    const piece = board[fr][fc];
    const victim = board[tr][tc];
    const pieceType = piece[1];
    
    // Base score (slight randomness to prevent repetitive loops)
    let score = Math.random() * 2; 

    // CAPTURE VALUE: Prioritize taking your pieces
    if (victim) {
        const victimType = victim[1];
        score += VALS[victimType] * 10;
    }

    // POSITIONAL VALUE: Reward control of the orbital center
    if (tc >= 6 && tc <= 9) {
        score += 8;
    }

    // SAFETY CHECK: Penalize moving into a square you can attack
    // This prevents the AI from "donating" its Queen to a Pawn
    if (isSquareAttacked(tr, tc, oppCol)) {
        score -= VALS[pieceType] * 8;
    }

    // KING THREAT: Huge bonus if this move wins the game
    if (victim && victim[1] === 'K') {
        score += 10000;
    }

    return score;
}

/**
 * Threat Matrix: Checks if a specific square is targeted by the opponent
 */
function isSquareAttacked(tr, tc, attackerCol) {
    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            if(board[r][c] && board[r][c][0] === attackerCol) {
                // We use a simplified check here to keep the AI fast
                const moves = getMoves(r, c);
                for(let i=0; i<moves.length; i++) {
                    if(moves[i].r === tr && moves[i].c === tc) return true;
                }
            }
        }
    }
    return false;
}

// ... (Keep existing executeMove, draw, and input logic) ...
</script>

canvas.onmousedown = e => {
    if (!gameActive || turn !== playerColor) return;
    const mx = e.offsetX - cam.x, my = e.offsetY - cam.y;
    const vdc = Math.floor(mx/CELL), vdr = Math.floor(my/CELL);
    if (vdr < 0 || vdr >= ROWS || vdc < 0 || vdc >= COLS) return;
    const { r, c } = getActualCoords(vdr, vdc);
    if (selected) {
        if (getMoves(selected.r, selected.c).some(m => m.r === r && m.c === c)) executeMove(selected, {r, c});
        selected = null;
    } else if (board[r][c] && board[r][c][0] === playerColor) selected = {r, c};
};

draw();
</script>
</body>
</html>




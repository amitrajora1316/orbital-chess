<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Orbital Chess | Arena Pro</title>
    <style>
        :root { --bg: #0d0d0f; --panel: #1a1a1e; --accent: #d4af37; --text: #ffffff; }
        body { background: var(--bg); color: var(--text); margin: 0; display: flex; font-family: 'Segoe UI', sans-serif; height: 100vh; overflow: hidden; }
        #sidebar { width: 320px; background: var(--panel); display: flex; flex-direction: column; padding: 15px; border-right: 2px solid #2d2d35; }
        .header h1 { font-size: 0.9rem; letter-spacing: 3px; color: var(--accent); text-align: center; margin-bottom: 20px; }
        #players-container { flex-grow: 1; overflow-y: auto; background: #111; border-radius: 8px; padding: 10px; border: 1px solid #333; margin-bottom: 15px; }
        .player-card { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 5px; border-bottom: 1px solid #222; font-size: 0.8rem; }
        #game-info { background: #25252b; padding: 15px; border-radius: 8px; text-align: center; margin-bottom: 15px; display: none; border-left: 4px solid var(--accent); }
        #timer-box { font-size: 1.5rem; font-weight: bold; color: var(--accent); margin-top: 5px; }
        .turn-label { font-size: 0.7rem; color: #888; text-transform: uppercase; }
        canvas { flex-grow: 1; cursor: crosshair; background: #000; }
        .btn { background: var(--accent); color: #000; border: none; padding: 8px 12px; border-radius: 4px; font-weight: 700; cursor: pointer; font-size: 0.7rem; }
        #login-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .login-box { text-align:center; background:#1a1a1e; padding:40px; border-radius:15px; border:1px solid var(--accent); }
        input { padding:12px; border-radius:5px; border:none; width:220px; background:#25252b; color:white; margin-bottom: 20px; text-align: center; }
    </style>
</head>
<body>

    <div id="login-overlay">
        <div class="login-box">
            <h1 style="color:var(--accent); letter-spacing:5px;">ORBITAL ARENA</h1>
            <input type="text" id="username-input" placeholder="Enter Nickname (Optional)">
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="btn" onclick="joinArena('human')">MULTIPLAYER</button>
                <button class="btn" style="background:#444; color:white;" onclick="joinArena('ai')">VS COMPUTER</button>
            </div>
        </div>
    </div>

    <div id="sidebar">
        <div class="header"><h1>VANGUARD PRO</h1></div>
        <div id="game-info">
            <div id="opp-name" style="font-size: 0.7rem; opacity: 0.6;">VS ---</div>
            <div class="turn-label" id="turn-text">WAITING...</div>
            <div id="timer-box">60s</div>
        </div>
        <div style="font-size: 0.7rem; color: #666; margin-bottom: 5px;">ACTIVE COMMANDERS</div>
        <div id="players-container">Connecting...</div>
        <button class="btn" style="background:none; border:1px solid #444; color:#666; margin-top: auto;" onclick="location.reload()">EXIT</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

<script>
    const firebaseConfig = {
        apiKey: "AIzaSyCjEnUBeg91At1NpkjVXg8gyfEF6Pf24J0",
        authDomain: "orbitalarena.firebaseapp.com",
        databaseURL: "https://orbitalarena-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "orbitalarena",
        storageBucket: "orbitalarena.firebasestorage.app",
        messagingSenderId: "265516321261",
        appId: "1:265516321261:web:a964edf2ba882ceff27fe4"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    const ROWS = 12, COLS = 16, CELL = 60;
    let board = Array(ROWS).fill().map(() => Array(COLS).fill(""));
    let turn = 'w', myId, myName, currentGameId = null, myColor = 'w', isAI = false;
    let selected = null, validMoves = [], timerInterval, timeLeft = 60;
    const PIECES = {'wK':'♔','wQ':'♕','wR':'♖','wB':'♗','wN':'♘','wP':'♙','bK':'♚','bQ':'♛','bR':'♜','bB':'♝','bN':'♞','bP':'♟'};

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function joinArena(mode) {
        const inputName = document.getElementById('username-input').value.trim();
        myId = "id_" + Math.random().toString(36).substr(2, 5);
        myName = inputName || "Guest_" + myId.split('_')[1];
        document.getElementById('login-overlay').style.display = 'none';

        if(mode === 'ai') { isAI = true; startAIGame(); } 
        else { initMultiplayer(); }
        requestAnimationFrame(render);
    }

    function initMultiplayer() {
        db.ref('players/' + myId).set({ name: myName });
        db.ref('players/' + myId).onDisconnect().remove();

        db.ref('players').on('value', snap => {
            const container = document.getElementById('players-container');
            container.innerHTML = "";
            snap.forEach(child => {
                if(child.key === myId) return;
                const div = document.createElement('div');
                div.className = 'player-card';
                div.innerHTML = `<span>${child.val().name}</span> <button class="btn" onclick="challenge('${child.key}')">FIGHT</button>`;
                container.appendChild(div);
            });
        });

        // FIXED: Listener ensures accepting player is set to Black ('b')
        db.ref('challenges/' + myId).on('value', snap => {
            const c = snap.val();
            if(c) {
                if(confirm(c.fromName + " challenges you! (Accept to play as BLACK)")) {
                    db.ref('challenges/' + myId).remove();
                    initGame(c.gameId, 'b', c.fromName);
                }
            }
        });
    }

    function challenge(targetId) {
        const gid = "g_" + Date.now();
        db.ref('challenges/' + targetId).set({fromName: myName, gameId: gid});
        initGame(gid, 'w', "Opponent"); // Challenger is always White
    }

    function initGame(gid, col, opp) {
        currentGameId = gid; 
        myColor = col; // 'w' for challenger, 'b' for acceptor
        document.getElementById('game-info').style.display = 'block';
        document.getElementById('opp-name').innerText = "VS " + opp;

        if(!isAI && col === 'w') {
            const nb = Array(ROWS).fill().map(() => Array(COLS).fill(""));
            ["R","N","B","Q","K","B","N","R"].forEach((p, i) => {
                nb[2][4+i] = "b"+p; nb[3][4+i] = "bP"; nb[9][4+i] = "w"+p; nb[8][4+i] = "wP";
            });
            db.ref('games/'+gid).set({board: nb, turn: 'w'});
        }

        db.ref('games/'+gid).on('value', snap => {
            const data = snap.val();
            if(data) { board = data.board; turn = data.turn; resetTimer(); }
        });
    }

    function resetTimer() {
        clearInterval(timerInterval);
        timeLeft = 60;
        document.getElementById('turn-text').innerText = (turn === myColor) ? "YOUR TURN" : "THEIR TURN";
        timerInterval = setInterval(() => {
            timeLeft--;
            document.getElementById('timer-box').innerText = timeLeft + "s";
            if(timeLeft <= 0) clearInterval(timerInterval);
        }, 1000);
    }

    function render() {
        canvas.width = window.innerWidth - 320;
        canvas.height = window.innerHeight;
        ctx.fillStyle = "#000"; ctx.fillRect(0,0,canvas.width,canvas.height);

        const offsetX = (canvas.width - (COLS * CELL)) / 2;
        const offsetY = (canvas.height - (ROWS * CELL)) / 2;

        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                // PERSPECTIVE FIX: If I am black, invert the display rows and columns
                let displayR = (myColor === 'b') ? (ROWS - 1 - r) : r;
                let displayC = (myColor === 'b') ? (COLS - 1 - c) : c;

                const x = displayC * CELL + offsetX;
                const y = displayR * CELL + offsetY;
                
                ctx.fillStyle = (r + c) % 2 === 0 ? "#e8d5b5" : "#8b6b4d";
                ctx.fillRect(x, y, CELL, CELL);
                
                if(selected && selected.r === r && selected.c === c) {
                    ctx.fillStyle = "rgba(212,175,55,0.5)"; ctx.fillRect(x, y, CELL, CELL);
                }

                if(board[r][c]) {
                    ctx.fillStyle = board[r][c][0] === 'w' ? "#fff" : "#000";
                    ctx.font = "35px Arial"; ctx.textAlign = "center";
                    ctx.fillText(PIECES[board[r][c]], x + CELL/2, y + CELL/2 + 12);
                }
            }
        }
        requestAnimationFrame(render);
    }

    canvas.addEventListener('mousedown', e => {
        if(turn !== myColor) return;
        const rect = canvas.getBoundingClientRect();
        let c = Math.floor((e.clientX - rect.left - (canvas.width - COLS*CELL)/2) / CELL);
        let r = Math.floor((e.clientY - rect.top - (canvas.height - ROWS*CELL)/2) / CELL);

        // PERSPECTIVE CLICK FIX: Revert screen clicks back to board logic
        if(myColor === 'b') {
            r = ROWS - 1 - r;
            c = COLS - 1 - c;
        }

        if(r < 0 || r >= ROWS || c < 0 || c >= COLS) return;

        const move = validMoves.find(m => m.r === r && m.c === c);
        if(move) {
            board[r][c] = board[selected.r][selected.c];
            board[selected.r][selected.c] = "";
            const nt = turn === 'w' ? 'b' : 'w';
            if(isAI) { turn = nt; makeAIMove(); } 
            else { db.ref('games/'+currentGameId).update({board, turn: nt}); }
            selected = null; validMoves = [];
        } else if(board[r][c] && board[r][c][0] === turn) {
            selected = {r, c};
            validMoves = getMoves(r, c);
        }
    });

    function getMoves(r, c) {
        const p = board[r][c]; if(!p) return [];
        const col = p[0], type = p[1], moves = [], fwd = col==='w'?-1:1;
        if(type==='P') {
            let nr = (r+fwd+ROWS)%ROWS; if(!board[nr][c]) moves.push({r:nr, c});
            [-1, 1].forEach(dc => {
                let nc = (c+dc+COLS)%COLS; if(board[nr][nc] && board[nr][nc][0]!==col) moves.push({r:nr, c:nc});
            });
        } else {
            const dirs = (type==='N') ? [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]] :
                         (type==='R') ? [[0,1],[0,-1],[1,0],[-1,0]] :
                         (type==='B') ? [[1,1],[1,-1],[-1,1],[-1,-1]] :
                         [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            const lim = (type==='K' || type==='N') ? 2 : 16;
            dirs.forEach(([dr, dc]) => {
                for(let i=1; i<lim; i++) {
                    let nr=(r+dr*i+ROWS)%ROWS, nc=(c+dc*i+COLS)%COLS;
                    if(board[nr][nc] && board[nr][nc][0]===col) break;
                    moves.push({r:nr, c:nc}); if(board[nr][nc]) break;
                }
            });
        }
        return moves;
    }

    function startAIGame() {
        myColor = 'w';
        const nb = Array(ROWS).fill().map(() => Array(COLS).fill(""));
        ["R","N","B","Q","K","B","N","R"].forEach((p, i) => {
            nb[2][4+i] = "b"+p; nb[3][4+i] = "bP"; nb[9][4+i] = "w"+p; nb[8][4+i] = "wP";
        });
        board = nb; turn = 'w';
        document.getElementById('game-info').style.display = 'block';
        document.getElementById('opp-name').innerText = "VS AI_BOT";
    }

    function makeAIMove() {
        setTimeout(() => {
            let all = [];
            for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) 
                if(board[r][c] && board[r][c][0]==='b') getMoves(r,c).forEach(m=>all.push({fr:r,fc:c,tr:m.r,tc:m.c}));
            if(all.length) {
                let m = all[Math.floor(Math.random()*all.length)];
                board[m.tr][m.tc]=board[m.fr][m.fc]; board[m.fr][m.fc]=""; turn='w';
            }
        }, 800);
    }
</script>
</body>
</html>

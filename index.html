<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Orbital Chess | Vanguard Pro</title>
    <style>
        :root { --bg: #0d0d0f; --panel: #1a1a1e; --accent: #d4af37; --text: #ffffff; }
        body { background: var(--bg); color: var(--text); margin: 0; display: flex; font-family: 'Segoe UI', sans-serif; height: 100vh; overflow: hidden; }
        
        #sidebar { 
            width: 240px; background: var(--panel); display: flex; flex-direction: column; 
            padding: 25px; border-right: 2px solid #2d2d35; box-shadow: 5px 0 25px rgba(0,0,0,0.5); 
        }
        .header h1 { font-size: 1.1rem; letter-spacing: 3px; color: var(--accent); text-align: center; margin-bottom: 30px; }
        
        .status-box { background: #25252b; padding: 15px; border-radius: 10px; text-align: center; margin-bottom: 20px; border: 1px solid #333; }
        #turn-txt { font-weight: 800; color: var(--accent); }

        .eval-section { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #eval-bar { width: 35px; height: 300px; background: #111; border-radius: 18px; position: relative; overflow: hidden; border: 2px solid #444; }
        #eval-fill { width: 100%; background: linear-gradient(to bottom, #fff, #999); position: absolute; bottom: 0; height: 50%; transition: height 0.6s ease-out; }

        canvas { flex-grow: 1; cursor: grab; background: radial-gradient(circle, #1a1a1e 0%, #0d0d0f 100%); }
        .btn { background: var(--accent); color: #000; border: none; padding: 12px; border-radius: 5px; cursor: pointer; font-weight: 700; margin-top: 20px; transition: 0.2s; }
        .btn:hover { transform: scale(1.05); }

        #menu-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="menu-overlay">
        <div style="text-align:center;">
            <h1 style="color:var(--accent); letter-spacing:10px; margin-bottom:40px;">ORBITAL VANGUARD</h1>
            <button class="btn" style="padding: 20px 60px; font-size: 1.2rem;" onclick="initGame()">ENGAGE AI</button>
        </div>
    </div>

    <div id="sidebar">
        <div class="header"><h1>VANGUARD</h1></div>
        <div class="status-box"><div id="turn-txt">WHITE'S TURN</div></div>
        <div class="eval-section">
            <span style="font-size: 0.7rem; opacity: 0.5; margin-bottom: 10px;">ADVANTAGE</span>
            <div id="eval-bar"><div id="eval-fill"></div></div>
        </div>
        <button class="btn" onclick="location.reload()">RESET</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ROWS = 12, COLS = 16, CELL = 75;
    let board = [], turn = 'w', selected = null, validMoves = [], isThinking = false;
    let camX = 100, camY = -180, isPanning = false, lastMouse = {x:0, y:0};

    // --- POSITIONAL KNOWLEDGE (PST) ---
    const PST = {
        'P': [0, 0, 10, 20, 30, 40, 40, 30, 20, 10, 0, 0],
        'N': [-20, -10, 0, 10, 20, 30, 30, 20, 10, 0, -10, -20],
        'K': [50, 40, 20, 0, -20, -40, -40, -20, 0, 20, 40, 50]
    };

    function initGame() {
        document.getElementById('menu-overlay').style.display = 'none';
        board = Array(ROWS).fill().map(() => Array(COLS).fill(""));
        const layout = ["R", "N", "B", "Q", "K", "B", "N", "R"];
        layout.forEach((p, i) => {
            board[2][4+i] = "b"+p; board[3][4+i] = "bP";
            board[9][4+i] = "w"+p; board[8][4+i] = "wP";
        });
        updateUI(); draw();
    }

    function getMoves(b, r, c) {
        const p = b[r][c]; if(!p) return [];
        const col = p[0], type = p[1], moves = [], fwd = col==='w'?-1:1;
        if(type==='P') {
            let nr = (r+fwd+ROWS)%ROWS; if(!b[nr][c]) moves.push({r:nr, c});
            [-1, 1].forEach(dc => {
                let nc = (c+dc+COLS)%COLS; if(b[nr][nc] && b[nr][nc][0]!==col) moves.push({r:nr, c:nc});
            });
        } else {
            const dirs = (type==='N') ? [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]] :
                         (type==='R') ? [[0,1],[0,-1],[1,0],[-1,0]] :
                         (type==='B') ? [[1,1],[1,-1],[-1,1],[-1,-1]] :
                         [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
            const lim = (type==='K' || type==='N') ? 2 : 12;
            dirs.forEach(([dr, dc]) => {
                for(let i=1; i<lim; i++) {
                    let nr=(r+dr*i+ROWS)%ROWS, nc=(c+dc*i+COLS)%COLS;
                    if(b[nr][nc] && b[nr][nc][0]===col) break;
                    moves.push({r:nr, c:nc}); if(b[nr][nc]) break;
                }
            });
        }
        return moves;
    }

    function evaluate(b) {
        const vals = {P:100, N:320, B:330, R:500, Q:900, K:20000};
        let s = 0;
        for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
            if(!b[r][c]) continue;
            let p = b[r][c][1], side = b[r][c][0];
            let val = vals[p] + (PST[p] ? PST[p][r] : 0);
            s += (side === 'b' ? val : -val);
        }
        return s;
    }

    function minimax(b, depth, alpha, beta, maximizing) {
        if (depth === 0) return evaluate(b);
        let color = maximizing ? 'b' : 'w';
        let moves = [];
        for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
            if(b[r][c].startsWith(color)) getMoves(b, r, c).forEach(m => moves.push({s:{r,c}, e:m}));
        }
        
        // Move Ordering: Check captures first for speed (Alpha-Beta Pruning)
        moves.sort((a, b) => (b[b.e.r][b.e.c] ? 1 : -1));

        let bestMove = null;
        if (maximizing) {
            let maxEval = -Infinity;
            for (let m of moves) {
                let target = b[m.e.r][m.e.c];
                b[m.e.r][m.e.c] = b[m.s.r][m.s.c]; b[m.s.r][m.s.c] = "";
                let ev = minimax(b, depth - 1, alpha, beta, false);
                b[m.s.r][m.s.c] = b[m.e.r][m.e.c]; b[m.e.r][m.e.c] = target;
                if (ev > maxEval) { maxEval = ev; bestMove = m; }
                alpha = Math.max(alpha, ev); if (beta <= alpha) break;
            }
            return depth === 3 ? {score: maxEval, move: bestMove} : maxEval;
        } else {
            let minEval = Infinity;
            for (let m of moves) {
                let target = b[m.e.r][m.e.c];
                b[m.e.r][m.e.c] = b[m.s.r][m.s.c]; b[m.s.r][m.s.c] = "";
                let ev = minimax(b, depth - 1, alpha, beta, true);
                b[m.s.r][m.s.c] = b[m.e.r][m.e.c]; b[m.e.r][m.e.c] = target;
                minEval = Math.min(minEval, ev);
                beta = Math.min(beta, ev); if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    async function runAI() {
        isThinking = true;
        setTimeout(() => {
            let res = minimax(board, 3, -Infinity, Infinity, true); 
            if (res.move) {
                board[res.move.e.r][res.move.e.c] = board[res.move.s.r][res.move.s.c];
                board[res.move.s.r][res.move.s.c] = "";
                turn = 'w'; updateUI();
            }
            isThinking = false;
        }, 50);
    }

    function updateUI() {
        document.getElementById('turn-txt').innerText = (turn === 'w' ? "WHITE" : "BLACK") + "'S TURN";
        let s = evaluate(board);
        document.getElementById('eval-fill').style.height = Math.max(5, Math.min(95, 50 - s/200)) + "%";
    }

    const PIECES = {'wK':'♔','wQ':'♕','wR':'♖','wB':'♗','wN':'♘','wP':'♙','bK':'♚','bQ':'♛','bR':'♜','bB':'♝','bN':'♞','bP':'♟'};
    function draw() {
        canvas.width = window.innerWidth - 240; canvas.height = window.innerHeight;
        for(let r=-1; r<ROWS+1; r++) {
            for(let c=-1; c<COLS+1; c++) {
                let rr=(r%ROWS+ROWS)%ROWS, rc=(c%COLS+COLS)%COLS;
                let x=c*CELL+camX, y=r*CELL+camY;
                ctx.fillStyle = (rr+rc)%2===0 ? "#e8d5b5" : "#8b6b4d"; ctx.fillRect(x,y,CELL,CELL);
                if(selected && selected.r===rr && selected.c===rc) { ctx.fillStyle="rgba(212,175,55,0.4)"; ctx.fillRect(x,y,CELL,CELL); }
                validMoves.forEach(m => { if(m.r===rr && m.c===rc) { ctx.fillStyle="rgba(0,0,0,0.1)"; ctx.beginPath(); ctx.arc(x+CELL/2,y+CELL/2,6,0,Math.PI*2); ctx.fill(); } });
                if(board[rr][rc]) { ctx.fillStyle=board[rr][rc][0]==='w'?'#fff':'#000'; ctx.font="45px serif"; ctx.textAlign="center"; ctx.fillText(PIECES[board[rr][rc]], x+CELL/2, y+CELL/2+15); }
            }
        }
        requestAnimationFrame(draw);
    }

    canvas.addEventListener('mousedown', e => {
        if(isThinking) return;
        let mx=e.offsetX-camX, my=e.offsetY-camY;
        let c=Math.floor(mx/CELL), r=Math.floor(my/CELL), rr=(r%ROWS+ROWS)%ROWS, rc=(c%COLS+COLS)%COLS;
        if(e.button===0) {
            let m=validMoves.find(mv => mv.r===rr && mv.c===rc);
            if(m) {
                board[rr][rc]=board[selected.r][selected.c]; board[selected.r][selected.c]="";
                turn='b'; selected=null; validMoves=[]; updateUI(); runAI();
            } else if(board[rr][rc] && board[rr][rc][0]===turn) {
                selected={r:rr, c:rc}; validMoves=getMoves(board, rr, rc);
            }
        } else { isPanning=true; lastMouse={x:e.clientX, y:e.clientY}; }
    });
    window.addEventListener('mousemove', e => { if(isPanning) { camX+=e.clientX-lastMouse.x; camY+=e.clientY-lastMouse.y; lastMouse={x:e.clientX, y:e.clientY}; } });
    window.addEventListener('mouseup', () => isPanning=false);
    window.oncontextmenu = (e) => e.preventDefault();
</script>
</body>
</html>
